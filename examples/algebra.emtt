{
  MonoidOn[t: @type]: @theory = {
    op: [x: t, y: t] -> t;
    zero: t;
    assoc: [x: t, y: t, z: t] -> op[x,op[y,z]] == op[op[x,y],z];
    unit: [x:t] -> op[x, zero] == x;
  };

  Monoid: @theory = {
    t: @type;
    m: MonoidOn[t];
  };

  CGroupOn[t: @type]: @theory = {
    m: MonoidOn[t];
    op := m.op;
    zero := m.zero;
    inv: [x: t] -> { val: t; op[x, val] == zero; };
    comm: [x: t, y: t] -> op[x, y] == op[y, x];
  };

  RingOn[t: @type]: @theory = {
    plus: CGroupOn[t];
    mul: MonoidOn[t];

    (+) := plus.op;
    zero := plus.zero;
    neg := plus.inv;
    (*) := times.op;
    one := times.zero;

    dist: [x: t, y: t, z: t] -> x * (y + z) == (x * y) + (x * z);
  };

  Lemmas[t: @type, R: RingOn[t]]: @theory = {
    %open R;

    neg_is_unique : [x: t, y: t, eq: x + y == zero] -> y == neg[x].val;

    mul_zero_is_zero: [x: t] -> x * zero == zero;

    negation_via_mul_neg_one_lemma: [x: t] -> x + neg[one].val * x == zero;

    negation_via_mul_neg_one: [x: t] -> neg[one] * x == neg[x];
  };
}
